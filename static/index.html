<!DOCTYPE html>
<html>
<head>
    <title>å¤šå®¢æˆ·ç«¯ä»£ç†ç®¡ç†å™¨</title>
    <style>

        /* æ–°å¢è¡¨æ ¼æ ·å¼ */
        .client-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .client-table th, .client-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .client-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
        }
        .status-indicator-new {
            display: inline-flex;  /* ä½¿ç”¨è¡Œå†…å¼¹æ€§å¸ƒå±€ */
            align-items: center;   /* å‚ç›´å±…ä¸­ */
            gap: 6px;             /* å…ƒç´ é—´è· */
            white-space: nowrap;  /* ç¦æ­¢æ–‡å­—æ¢è¡Œ */
            line-height: 1;       /* ç»Ÿä¸€è¡Œé«˜ */
        }
        .status-indicator .icon {
            flex-shrink: 0;       /* ç¦æ­¢å›¾æ ‡ç¼©æ”¾ */
            font-size: 1em;       /* ä¸æ–‡å­—å¤§å°åŒæ­¥ */
        }
        .online { background: #28a745; }
        .offline { background: #dc3545; }
        .config-form { margin: 20px 0; }
        /* æ–°å¢é”™è¯¯æç¤ºæ ·å¼ */
        .error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #dc3545;
            color: white;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* æ–°å¢å¿ƒè·³çŠ¶æ€é¢œè‰² */
        .reconnecting { background: #ffc107; }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 480px) {
            .status-indicator {
                font-size: 0.9em;
                gap: 4px;
            }
        }



    </style>
</head>
<body>
<h1>å¤šå®¢æˆ·ç«¯ä»£ç†ç®¡ç†å™¨</h1>

<div class="config-form">
    <h2>æ·»åŠ æ–°å®¢æˆ·ç«¯</h2>
    <form onsubmit="createClient(event)">
        <input type="text" id="newClientName" placeholder="å®¢æˆ·ç«¯åç§°" required>
        <input type="url" id="newProxyTarget" placeholder="ä»£ç†ç›®æ ‡åœ°å€" required>
        <button type="submit">æ·»åŠ å®¢æˆ·ç«¯</button>
    </form>
</div>

<table class="client-table">
    <thead>
    <tr>
        <th>å®¢æˆ·ç«¯</th>
        <th>å®¢æˆ·ç«¯IP</th>
        <th>ä»£ç†çŠ¶æ€</th>
        <th>ä»£ç†ç›®æ ‡</th>
        <th>æ“ä½œ</th>
    </tr>
    </thead>
    <tbody id="clientList">
    <!-- åŠ¨æ€ç”Ÿæˆ -->
    </tbody>
</table>

<h2>å¿ƒè·³çŠ¶æ€ç›‘æ§</h2>
<table class="client-table">
    <thead>
    <tr>
        <th>èŠ‚ç‚¹åç§°</th>
        <th>IP</th>
        <th>åœ¨çº¿çŠ¶æ€</th>
    </tr>
    </thead>
    <tbody id="heartbeatList">
    <!-- åŠ¨æ€ç”Ÿæˆ -->
    </tbody>
</table>

<!-- æ–°å¢é”™è¯¯æç¤ºå®¹å™¨ -->
<div id="errorToast" class="error-toast"></div>

<script>
    let lastClientData = null;
    let pollTimer = null;
    // çŠ¶æ€é…ç½®
    const STATUS_MAP = {
        0: {
            text: 'ç¦»çº¿',
            color: '#ff4d4f',
            icon: 'ğŸ”´' // æˆ–ä½¿ç”¨å­—ä½“å›¾æ ‡<i class="icon-offline"></i>
        },
        1: {
            class: 'active',
            text: 'åœ¨çº¿',
            color: '#52c41a',
            icon: 'ğŸŸ¢'
        },
        2: {
            class: 'reconnecting',
            text: 'é‡è¿ä¸­',
            color: '#faad14',
            icon: 'ğŸŸ¡'
        }
    };

    // åŠ¨æ€æ¸²æŸ“å®¢æˆ·ç«¯åˆ—è¡¨
    function renderClients(clients) {
        const tbody = document.getElementById('clientList');
        tbody.innerHTML = '';

        clients.forEach(client => {
            const row = document.createElement('tr');

            // çŠ¶æ€æŒ‡ç¤ºå™¨
            const proxyStatus = `
                    <span class="status-indicator ${client.enabled ? 'online' : 'offline'}"></span>
                    ${client.enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}
                `;


            // æ“ä½œæŒ‰é’®
            const actions = `
                    <button onclick="toggleClient('${client.id}')">${client.enabled ? 'ç¦ç”¨' : 'å¯ç”¨'}</button>
                    <button onclick="deleteClient('${client.id}')">åˆ é™¤</button>
                `;

            row.innerHTML = `
                    <td>${client.name}</td>
                    <td>${client.ip}</td>
                    <td>${proxyStatus}</td>
                    <td>${client.proxy_target}</td>
                    <td>${actions}</td>
                `;

            tbody.appendChild(row);
        });
    }

    // è·å–å®¢æˆ·ç«¯åˆ—è¡¨
    function loadClients() {
        fetch('/api/clients')
            .then(r => r.json())
            .then(renderClients);
    }

    // åˆ›å»ºæ–°å®¢æˆ·ç«¯
    // å¢å¼ºåŸæœ‰APIè°ƒç”¨ï¼ˆç¤ºä¾‹ä¿®æ”¹createClientï¼‰
    function createClient(e) {
        e.preventDefault();
        const newClient = {
            name: document.getElementById('newClientName').value,
            proxy_target: document.getElementById('newProxyTarget').value,
        };

        fetch('/api/clients/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newClient)
        })
            .then(response => {
                if (!response.ok) throw new Error('åˆ›å»ºå¤±è´¥ï¼šæœåŠ¡å™¨è¿”å›é”™è¯¯');
                return response.json();
            })
            .then(loadAllData)
            .catch(err => showError(err.message));
    }

    // åˆ‡æ¢å®¢æˆ·ç«¯çŠ¶æ€
    function toggleClient(clientId) {
        fetch(`/api/clients/${clientId}/toggle`, {
            method: 'POST'
        }).then(loadClients);
    }

    // åˆ é™¤å®¢æˆ·ç«¯
    function deleteClient(clientId) {
        if (confirm('ç¡®å®šè¦åˆ é™¤è¯¥å®¢æˆ·ç«¯å—ï¼Ÿ')) {
            fetch(`/api/clients/${clientId}`, {
                method: 'DELETE'
            }).then(loadClients);
        }
    }
    let errorCache = {
        lastErrorTime: 0,
        errorMessage: '',
        showCount: 0
    };
    // æ–°å¢é”™è¯¯å¤„ç†å‡½æ•°
    // æ›´æ–°åçš„é”™è¯¯æç¤ºæ–¹æ³•
    function showError(message) {
        const now = Date.now();
        const isSameError = message === errorCache.errorMessage;

        // é”™è¯¯æŠ‘åˆ¶è§„åˆ™ï¼š
        // 1. ç›¸åŒé”™è¯¯5åˆ†é’Ÿå†…æœ€å¤šæ˜¾ç¤º3æ¬¡
        // 2. ç›¸åŒé”™è¯¯é¦–æ¬¡ç«‹å³æ˜¾ç¤ºï¼Œåç»­æ¯2åˆ†é’Ÿæ˜¾ç¤ºä¸€æ¬¡
        if (isSameError) {
            if (now - errorCache.lastErrorTime < 120000 && errorCache.showCount >= 3) {
                return;
            }
        } else {
            errorCache = { lastErrorTime: now, errorMessage: message, showCount: 0 };
        }

        errorCache.showCount++;
        errorCache.lastErrorTime = now;

        // å®é™…æ˜¾ç¤ºé€»è¾‘
        const toast = document.getElementById('errorToast');
        toast.textContent = `${message} (${errorCache.showCount}æ¬¡)`;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 5000);
        adjustPolling(true);
    }

    // å¿ƒè·³çŠ¶æ€æ¸²æŸ“ todo
    function renderHeartbeats(heartbeats) {
        const tbody = document.getElementById('heartbeatList');
        tbody.innerHTML = '';

        heartbeats.forEach(hb => {
            const row = document.createElement('tr');
            const duration = Math.floor((Date.now() - new Date(hb.lastCheck).getTime()) / 1000);

            // <td> <span class="status-indicator ${hb.state}"></span> ${hb.state.charAt(0).toUpperCase() + hb.state.slice(1)}</td>
            // <td>${new Date(hb.lastCheck).toLocaleString()}</td>
            // <td>${hb.state === 'offline' ? `${duration}ç§’` : '-'}</td>

            row.innerHTML = `
                <td>${hb.name}</td>
                <td>${hb.ip}</td>
                <td title="æœ€åå¿ƒè·³: ${hb.lastCheck}">
                    <span class="status-indicator-new ${STATUS_MAP[hb.state].class}">
                        ${STATUS_MAP[hb.state].icon}${STATUS_MAP[hb.state].text}
                    </span>
                </td>
            `;
            tbody.appendChild(row);
        });
    }

    // è·å–å¿ƒè·³æ•°æ®
    // function loadHeartbeats() {
    //     fetch('/api/heartbeats')
    //         .then(response => {
    //             if (!response.ok) throw new Error(`HTTPé”™è¯¯ ${response.status}`);
    //             return response.json();
    //         })
    //         .then(renderHeartbeats)
    //         .catch(err => showError(`å¿ƒè·³ç›‘æ§ä¸å¯ç”¨: ${err.message}`));
    // }

    // æ·±åº¦æ¯”è¾ƒå·¥å…·å‡½æ•°
    function deepEqual(a, b) {
        return JSON.stringify(a) === JSON.stringify(b);
    }

    // æ·»åŠ åŠ è½½çŠ¶æ€é”
    let isLoading = false;

    async function loadAllData() {
        if (isLoading) return;

        isLoading = true;
        try {
            const [clients, heartbeats] = await Promise.allSettled([
                fetch('/api/clients').then(r => r.json()),
                fetch('/api/heartbeats').then(r => r.json())
            ]);

            // ä»…åœ¨æœ‰æ•°æ®å˜åŒ–æ—¶æ›´æ–°DOM
            if (!deepEqual(clients.value, lastClientData)) {
                renderClients(clients.value);
                lastClientData = clients.value;
            }

            // å¿ƒè·³æ•°æ®å¼‚å¸¸æ—¶é™é»˜è®°å½•
            if (heartbeats.status === 'rejected') {
                console.warn('å¿ƒè·³æ›´æ–°å¤±è´¥:', heartbeats.reason);
            } else {
                renderHeartbeats(heartbeats.value);
            }
        } catch (err) {
            // ç½‘ç»œçº§é”™è¯¯æ‰æç¤ºç”¨æˆ·
            if (err instanceof TypeError) {
                showError(`ç½‘ç»œè¿æ¥å¼‚å¸¸: ${err.message}`);
            }
        } finally {
            isLoading = false;
        }
    }
    loadAllData();

    let pollInterval = 8000; // åˆå§‹é—´éš”
    const maxInterval = 60000; // æœ€å¤§é—´éš”

    function adjustPolling(hasError) {
        if (hasError) {
            pollInterval = Math.min(pollInterval * 2, maxInterval);
        } else {
            pollInterval = 8000;
        }

        clearInterval(pollTimer);
        pollTimer = setInterval(loadAllData, pollInterval);
    }

    function handleSuccess() {
        adjustPolling(false);
    }

    // ä¿®æ”¹åˆå§‹åŒ–é€»è¾‘
    setInterval(loadAllData, 8000); // ç¼©çŸ­ä¸º3ç§’åˆ·æ–°

</script>
</body>
</html>